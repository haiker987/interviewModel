### 1、对原型链的理解

javascript 对象里有一个属性叫 prototype，也称作原型，它指向另一个对象或者 null---Object.`__proto__`.Prototype=null，
当我们查找某个属性和方法时，会按照原型链一步一步向上查找，直到找到该属性和方法，或到达原型链顶端即 Object.prototype 为止

目的节省内存----可以继承、共享属性和方法

### 2、map 和 Object 的区别 

1.键的类型 2. 键值对的顺序 3.大小的获取 4.原型链 5.迭代器：

### 3、this 指向

this是一个关键字，它指向的是它调用的对象

当函数被调用的时候会创建函数执行上下文，它包含了函数在哪调用的（调用栈）、函数的调用方式、以及传入的参数等信息，this就是这个记录的属性，在函数只执行的时候会被用到

函数调用方式

1. 普通函数调用：这是最基本的函数调用方式，通过函数名和参数列表来调用函数。例如，在 JavaScript 中可以使用 `functionName(argument1, argument2)` 的形式来调用函数。
2. 递归调用：函数可以直接或间接地调用自身，这种方式被称为递归调用。递归在算法和数据结构中经常被使用，例如在树的遍历和排序算法中。
3. 匿名函数调用：在一些编程语言中，可以直接定义并调用匿名函数，而不需要给函数命名。这种方式在函数式编程语言中很常见。
4. 回调函数调用：在异步编程中，可以将函数作为参数传递给其他函数，在特定的事件发生时进行回调。这种方式在事件驱动的编程模型中经常被使用。
5. 方法调用：在面向对象编程中，函数可以作为对象的方法进行调用，通过对象实例来调用函数。
6. 动态调用：一些编程语言支持动态调用函数，可以在运行时根据条件来确定调用哪个函数。

常见有四种指向：默认绑定，隐私绑定，显示绑定（call、apply、bind），new 绑定
<img src="image.png" alt="Alt text" style="zoom:67%;" />

  **特殊的this指向**
1、setTimeout 和 setInterval   --window
2.forEach、find、findIndex、map ---，第二个参数，为空就是window
3.IIFE立即执行函数--window
4、箭头函数 ---

### 4、闭包的作用、原理和使用场景

闭包让你可以在一个内层函数中访问到其外层函数的作用域，闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者说闭包是个内嵌函数。

作用：利用闭包实现缓存

闭包产生的本质就是：**当前环境中存在指向父级作用域的引用。**

#### 下面来看看闭包的表现形式及应用场景

1、在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包：

2、**作为函数参数传递的形式：**

3、IFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量：

4、**结果缓存（备忘模式）**

### 5、正向代理和反向代理的区别

正向代理和反向代理是两种不同类型的代理服务器，它们在网络通信中扮演不同的角色。

1. 正向代理（Forward Proxy）：
   - 正向代理作为客户端的代理，代表客户端向其他服务器发送请求。客户端需要通过正向代理来访问其他服务器，因为直接访问会受到限制或阻止。
   - 举个例子，当你在公司内部网络中访问互联网时，你可能需要通过公司的正向代理服务器来访问外部网站，因为公司的网络设置了防火墙或者其他安全限制。
2. 反向代理（Reverse Proxy）：
   - 反向代理作为服务器的代理，代表服务器接收客户端的请求并将请求转发到内部的服务器。客户端不知道自己实际正在与哪个服务器通信，因为所有的请求都是发送到反向代理服务器。
   - 举个例子，当你访问一个网站时，你实际上在与反向代理服务器通信，它会将你的请求转发到后端的多个服务器上，然后将结果返回给你。

总的来说，正向代理是代表客户端发出请求，而反向代理是代表服务器接收请求。它们的主要区别在于代理的角色不同，以及它们在网络通信中的位置和功能不同。

### 6、箭头函数和普通函数的区别

### 7、ES6新特性

### 8、promise.all和promise.allSettled的区别

### 9、subString、subStr区别

### 10、symbol作用和使用场景

### 11、JS脚本异步加载

### 12、typeof和intanceof区别

### 13、forEach、map是否可以break

### 14、如何判断数组类型

### 15、操作数组元素的方法有哪些

```
1。Object.prototype.toString.call(obj).slice(8,-1) ---'Array'
2.Array.isArray()
3.obj.__proto__===Array.prototype
4.obj instanceof Array
5.Array.prototype.isPrototypeof(obj)
```

### 16、sort排序算法的本质？

### 17、如何拷贝一个对象？如何实现深浅拷贝

#### 1、浅拷贝

```javascript
1.直接赋值
2。使用Object.assign()
3.扩展运算符
4.手写浅拷贝
```

#### 2、深拷贝

```javascript
1.JSON.stringify()
2.lodash.cloneDeep()
3.手写深拷贝
```

### 18、splice和slice会改变原数组吗？如何删除数组最后一个元素？

```javascript
1.splice(-1,1)
2.slice(0,-1)
3.pop()
4.delete a.length-1
```

### 19、0.1+0.2为什么不等于0.3？

```javascript
1.二进制转换的过程中精度丢失
2.计算的过程中精度丢失

解决：
	1.将数字转化成整数
    2.使用第三方库
    3.使用tofixed
```

### 20、== 和 === 的区别

```javascript

```

### 21、解释 requestAnimationFrame/requestIdleCallback，分别有什么用

requestAnimationFrame 和 requestIdleCallback 都是浏览器提供的用于在下一次浏览器重绘之前执行指定函数的方法，它们的作用类似。它们的区别在于：

1. 回调函数的执行时机：requestAnimationFrame 的回调函数在下一次浏览器重绘之前执行，通常为每秒60次（60fps）；而requestIdleCallback 的回调函数在浏览器空闲时执行，即在浏览器没有其它任务时执行，通常为每秒几次（不确定，取决于浏览器）。
2. 回调函数的参数：requestAnimationFrame 的回调函数会被传入一个时间戳参数，表示当前帧开始渲染的时间；而requestIdleCallback 的回调函数会被传入一个 IdleDeadline 对象，包含了当前空闲时间的一些信息。 因此，当需要在下一次浏览器重绘之前执行某些操作时，应该使用requestAnimationFrame；当需要在浏览器空闲时执行一些较为耗时的操作时，应该使用requestIdleCallback。使用这两个方法可以避免造成页面卡顿或阻塞，提高用户体验。需要注意的是，由于requestIdleCallback的回调函数可能会在多次空闲时间内执行，因此应该根据实际情况合理地控制回调函数的执行次数和执行时间，以避免占用过多的浏览器资源

### 22、解释 requestAnimationFrame/requestIdleCallback，分别有什么用

RAF和RIC都是浏览器用于在下一次浏览器重绘之前执行指定函数的方法，他们的作用类似

RAF是用下一次浏览器重绘之前执行，通常时间为60s，而RIC是需要在浏览器空闲去执行的，如果没有空闲时间是不会执行的

### 23、谈下事件循环机制？

首先，浏览器的所有任务都是在一条线程上处理，即单线程

这样的坏处是，当执行一条任务时，这条任务执行的时间很长或者无响应，就会阻塞后面的任务，所以浏览器给出了一个方案，就是分为同步任务和异步任务，

异步任务是包括宏任务和微任务

其中常见的宏任务有全局的Script、settimeout、setInterval、IO操作、UI交互操作、以及nodejs中的setimmediate

常见的微任务有：Promise.then、async,await promise的语法糖、Process.nexTick、mutaionObserver

浏览器的EventLoop：

首先浏览器在执行代码的时候有两个概念，一个是执行栈，一个是任务队列

栈是先进后出，也就是函数的执行的时候，是后进去的先执行，pop（）

任务队列是先进先出，也就是当有宏任务或者微任务的时候，都会放进各自的任务队列里去等待执行，shift（）

总结：

在浏览器执行代码的过程中，首先执行全局的同步的代码，执行的过程中，如果发现有宏任务或者微任务，就会放进各自的任务队列去等待完成，随着同步的任务执行完成，先会去查看微任务队列是否存在任务，如果不存在就会开始将宏任务中的第一个任务取出，去执行；如果存在那就回优先执行微任务队列的任务；当执行宏任务的时候，如果宏任务中也包含微任务的话，那就会继续把微任务放进微任务队列，然后依次去执行微任务队列，直到所有的宏任务和微任务都执行完成，浏览器的一次事件循环就结束了

#### 说一下node环境中的事件循环

首先node中也含有像浏览器中的一些异步操作，例如：IO操作：readFIleAsyc、process.nextTick、setImmdeiate

还有就是node中其实是利用libuv去执行js脚本，以及node，他们是怎么操作的呢？

首先v8引擎会去处理js脚本，node处理解析后的代码，而libuv库就是去处理nodeAPi的执行，将他们分配给不同的线程去执行，形成一个eventloop，最后以异步的形式去返回结果给v8引擎

一共六个阶段

timer阶段：处理定时器等，回调是在poll阶段执行

io操作阶段：处理io事件，回调也是在poll阶段执行

idle，prepare阶段：处理系统事件，可以忽略

poll阶段:处理timer的回调和io的回调

check阶段：处理setlmmdeiate的回调

close阶段：处理close的回调

其中poll阶段比较复杂，分为几种情况：

如果没有设定timer时间（timer时间为下一次触发时间减去当前时间），

则poll队列是否为空，如果不为空的话，就会遍历去执行所有的回调，直到回调完成或者达到系统限制（这里的系统限制指的是系统的递归深度，默认为1000）；

如果为空的话，则会判断setlmmdeiate是否有回调需要执行，如果有则会进去check阶段去执行回调；如果没有回调要切执行，它就会等待回调被加入到队列中，这个等待时间是有限制的，不会无限的等待下去。

如果有设定timer时间且poll队列为空的话，则会判断是否有timer超时，如果有的就会回到timer阶段执行回调，如果队列不为空，则执行回调

### 24、**介绍一下防抖和节流**

防抖：防抖就是事件被触发n秒后再执行回调函数，可能在n秒内又触发了这个事件，则会重新计时，这样就确保了最后一次触发事件的n秒后去执行回调函数，从而减少回调函数的调用次数

节流：节流就是在一段时间内只会执行一次回调函数，如果在这段时间内又触发了这个事件，则忽略该事件，这样就确保了最后一次触发事件的n秒后去执行回调函数，从而减少回调函数的调用次数

时间戳版可能无法指定时间去执行回调函数

### 24、**事件冒泡和捕获的区别？默认是冒泡还是捕获？**

事件流指的是，事件触发的顺序会按照先捕获和冒泡的规则，也就是捕获阶段，目标阶段，冒泡阶段

事件冒泡：事件接受后，开始逐级向上传播到Dom的顶层节点的过程

div > body > html >document >window

事件捕获：document对象在接受到点击事件后，会沿着dom树向下传播，直到传播到事件的目标位置

window > document > html > body > div

默认是冒泡

onclick 和attchevnet只能获取冒泡阶段

addEventListener 的第三个参数如果是true的话，则表示是捕获阶段，默认是false，也就是冒泡阶段

有些事件没有事件冒泡，如 blur 、focus、mouseenter、mouseleave

#### 如何阻止事件冒泡呢

1.可以使用e.stopProgation阻止事件冒泡 // 

2.使用addEventListener 的第三个参数设置为true，也就是捕获阶段

阻止默认行为

addEventListener 的话只有一种 e.preventDefault

如果是onclick 可以使用return false



冒泡的应用也就是事件委托也叫事件代理

### 25、**什么是事件代理？**

也就是通过事件捕获或者事件冒泡，把一系列内层元素的事件绑定到外层元素，作用是减少操作的Dom的次数，提高程序的性能并且在动态添加或删除列表项时也不需要重新绑定事件处理程序，这使得代码更加简洁、灵活且易于维护。

比如动态创建子元素，给ul绑定事件，那每一个子元素也会有事件

### 26、**mouseover 和 mouseenter 的区别？**





### 27、**浏览器缓存策略**

两种，强缓存和协商缓存

强缓存：

expires：http1.0

cache-control:http1.1



协商缓存：

last-modified：http1.0

Etag：http1.1



### 28、**浏览器内核是什么？包含什么？常见的有哪些？**

浏览器内核是由js引擎和渲染引擎组成的

 （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；
 （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；
 （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；
 （4） Safari 浏览器内核：Webkit 内核；
 （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
 （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；
 （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
 （8） 百度浏览器、世界之窗内核：IE 内核；



### 29、**打开了两个标签页是进程还是线程？**

进程

打开浏览器的一个页面，需要四个进程： gpu进程、渲染进程、网络进程、浏览器进程（插件进程）



渲染进程中的线程

gui线程

js引擎线程

计时器线程

http线程

事件触发线程

### 30、**浏览器从输入网址到页面加载的整个过程** 

1、解析url：对url进行分析，分析传输协议和路径地址，如果协议和主机名不合法，则直接交给搜索引擎，如果没有问题，则会检查url的非法字符，如果有则进行转义

2、缓存判断：浏览器会判断请求的资源是否在缓存中，如果在则直接使用，返回304，否则发送新的请求

3、dns解析：为了获取真正的ip地址，

首先获取输入的域名的ip地址，判断在本地是否有缓存，如果有缓存，则直接用，如果没有，则会向dns服务器去发送请求，先请求本地dns服务器，看看是否有缓存，根域名服务器发送请求，顶级域名服务器，权威域名服务器，最后本地dns服务器会将真正的ip地址返回给用户。

4、获取mac地址：获取主机的mac地址。

5、tcp三次握手：为了建立网络连接

首先客户端会向服务器一个请求和一个随机序号，

服务器接受到之后，向客户端返回一个保报文段，确认连接请求，并向客户端发送一个随机序号

客户端收到确认应答后，进入连接状态，同时像服务器发送一个确认连接报文段，服务器收到确认后，也进入连接状态，此时双方的连接就建立起来了

6、https握手：对数据进行加密传输

 TLS 的一个四次握手的过程。

客户端--服务端   发送版本号，随机数，和加密的方法

服务器-客户段  确认加密的方法，返回一个随机数和数字证书

客户端-服务端   检查数字证书是否有效，有效的话生成一个随机数，并使用数字证书的公钥对随机数进行加密，并且提供一个hash值

服务端-客户端 用私钥进行解密，同时返回一个hash供客户端校验，这时候就有三个随机数，使用之前的加密方法，对随机数生成一个密钥，以后双方通信就直接使用这个密钥了

7、返回数据页面渲染

8、tcp的四次挥手：为了断开连接

客户端-服务端 发送一个连接释放请求

服务端-客户端  服务端  ack包然后进入等待状态，客户端与服务端的连接已经释放，此时服务端不在接受客户端的数据了，但是鱿鱼tcp是双向的，所以服务端可能还有没有传递完成的数据，如果有则继续发送，发送完后便进入last-ack状态

客户端-服务端 向服务器发送确认应答 ， time-wiat状态，该状态会存在一段时间，后进入closed状态

服务器收到确认应答后，也进入closed状态

### 31、**前端模块化机制？**

五种：

commonjs、amd、cmd、umd、esmodule、IIFE自执行函数

### 32、**ES Module 和 commonjs 的区别？**

es6module是值的引用，commonjs是值的拷贝

es6是编译的时候输出接口，commonjs是运行才加载

es6是异步加载，commonjs是同步加载，因为commonjs是运行在node中，文件在本地，而es6是在浏览器运行，所以需要支持异步加载

es6支持tree-shaking，commonjs不支持

esmodule的数据是同步的

### 33、**cookie、localStorage、sessionStorage、IndexedDB 的区别？**

4k 5M 5M

### 34、**cookie 里面都包含什么属性？**

1. Domain：设置主机名，设置浏览器允许哪些主机可以访问cookie；作用，减少域的限制并可以在子域里访问

2. Path:指定访问cookie的必须存在请求url中的路径，除了使用域之外，还可以使用路径

3. Expires/max-size：设置cookie的过期时间，如果没有设置，那么就是和session一起失效

4. secure：https才可以访问

5. httponly：使cookie只能通过服务端访问，并且客户端无法通过js去获取 很重要，可以防止xss攻击

   

### 35、**Cookie能跨域吗？如何设置？**

同一域名下，cookie是可以的共享的，而不同域名下，默认情况下是不共享的

可以跨域，需要设置

1. 响应头设置Access-Control-Allow-Credentials: true，表示允许发送cookie，与前端的withCredentials配合使用
2. 响应头设置Access-Control-Allow-Origin：域名，请求域名，表示允许该域名下的请求访问资源

### 36、**对 CORS 的理解**

首页是一种机制，跨域资源共享机制，也就是域，协议，端口不同时，会发起一个http请求，cors需要服务器和浏览器同时支持

浏览器把cors分为简单请求和非简单请求

简单请求不会触发cors预检请求，满足以下条件就是简单请求

1.   请求方法是以下方法之一
   1. HEAD
   2. GET
   3. POST
2.   **HTTP的头信息不超出以下几种字段**

简单请求的过程：

​	对于简单请求，浏览器会直接发出cors请求，它会子啊头信息中增加一个origin字段，该字段表明请求来自于哪个源（协议+域名+端口），服务器会根据这个值来决定是否同意这个请求，如果origin指定的域名在许可范围内，服务器返回的响应头就会多出以下信息

​	Access-Control-Allow-Origin:跟orgin一致

​	Access-Control-Allow-Credentials：true // 表示可以允许发送cookie

​	Access-Control-Expose-Headers：FooBar // 指定返回其他字段的值

​	content-type:text-html; charset=utf-8// 表示文档类型

如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。

在简单请求中，在服务器内的响应头，至少需要设置字段：Access-Control-Allow-Origin

非简单请求的过程

​	一般是DELETE或则PUT等这些请求，也就是非简单请求的时候，会在通信前进行一次预检请求，也就是Options请求



浏览器会询问服务器，当前网页是否在服务器的允许访问的范围内，以及可以使用哪些http请求方式和头信息字段，只要得到了肯定的答复，才会进行正式的请求，否则就会报错，返回403



预检请求使用的方法是Options，这个请求就是来询问服务器，它的头信息里有一个origin字段，表示来自哪个源，除此之外，来包括

'Access-Control-Allow-Origin' 

**Access-Control-Request-Method**：用来列出浏览器的CORS请求会用到哪些HTTP方法。

Access-Control-Request-Headers： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段



服务器收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息中含有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。返回403

```js
Access-Control-Allow-Origin: http://api.bob.com  // 允许跨域的源地址
Access-Control-Allow-Methods: GET, POST, PUT // 服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header  // 服务器支持的所有头信息字段
Access-Control-Allow-Credentials: true   // 表示是否允许发送Cookie
Access-Control-Max-Age: 1728000  // 用来指定本次预检请求的有效期，单位为秒
```

只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。



减少OPTIONS请求次数：

​	OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。

CORS中Cookie相关问题：
在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：
**●**在请求中设置 withCredentials
默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie

**Access-Control-Allow-Origin**

**Access-Control-Allow-**Credentials****

### 37、**如何检查内存泄露?**

**使用性能分析器可视化内存消耗**

**识别分离的 DOM 节点**

### 38、**https 加密是怎样的?**

#### 1. 什么是HTTPS协议？

​	超文本传输协议简称https，也就是通信使用http，但是数据数据传输使用ssl或者tsl进行加密，https就是为了提供服务器的身份认证，以及保证数据的隐私和完整性

​	http 采用的是明文传输，数据容易窃取，而ssl和tsl具有身份认证、信息加密和数据完整性校验的功能，可以避免此类问题发生

#### 2. TLS/SSL的工作原理

​	全称为安全传输层协议，是介于tcp和http之间的一层安全协议

​	ssl和tls使用有三种算法，散列函数hash、对称加密和非对称加密

​	使用过程：非对称加密进行身份认证和密钥的协商、对称加密使用协商的密钥对数据进行加密、散列函数就是验证数据的完整性

​	非对称加密

​		非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，**加密的速度慢**

​		非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题

​	对称加密

​		对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。

​	散列函数	

​		常用的散列函数有md5、SHA1,SHA256,他是单向不可逆的，对输入的数据非常敏感，输出的长度是固定的，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。

​	因为是明文传输，所以需要对传输的信息和信息摘要进行加密，可以用于防止信息篡改并验证数据的完整性

> 综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。

#### 3. 数字证书是什么？

​	现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。

首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。

### 39、**HTML文档的生命周期有哪些？**

DOMContentLoaded会被script阻塞

onload

beforeunload

unload

### 40、**如何解决跨域问题？**



### 41、**Content-Type 值有哪些？**

表单格式

文件格式

json

text/xml

### 42、**常见状态码的含义？**

101 切换请求协议，从 HTTP 切换到 WebSocket

200 请求成功，有响应体，服务器成功返回网页

301 永久重定向：会缓存

302 临时重定向：不会缓存

303 正常请求重定向，使用get重定向

304 协商缓存命中

400 请求错误

401 用户认证失败

403 服务器禁止访问

404 资源未找到，请求的网页不存在

500 服务器端错误

502 服务器请求超时

503 服务器停机维护，或者nginx设置了限速

504 服务器请求超时，通常是代码执行时间超时

### 43、**get 和 post 的区别？** 6 种

​	1.应用场景不同

​		get一般就是获取数据的，post一般就是新增或修改数据

​	2.是否缓存

​		浏览器一般会对get进行缓存，很少会post进行缓存

​	3.发送的报文格式

​		get请求报文的实体是空的，而post的请求报文一般向服务器发送的数据

​	4.安全性

​		get会把参数放在url上，相对于post不太安全

​	5.请求长度

​		浏览器对url有长度限制，所以会影响get请求的参数的长度

​	6.参数类型

​		post支持更多的类型

### 44、**HTTP 2.0 有哪些改进？**5种

​	1.二进制协议 

​			指的是报文的头信息，帧的概念是实现多路复用的基础

​	2.多路复用 

​			服务器和客户端可以同时发送多个请求，而不是按照以前一一发送，这样就避免了队头阻塞的问题

​	3.数据流

​			因为数据包是无序发送的，所以需要使用数据流id来规定每一次发送的请求和回应的数据，来区别他们是哪一个数据流

​	4.头信息压缩

​			在之前会有重复的头信息字段，所以需要对头信息数据进行压缩，使用gzip或compress压缩后在发送，另一方面，客户端和服务端各维护一张头信息表，所有的字段存入这一张表里，生成一个索引号，以后发送相同的头信息字段就直接发送索引号就行了

​	5.服务器推送

​			支持服务器推送一些静态资源，和websocket不同



### 45、**XSS和CSRF是什么？如何防御？**

​	1、xss

​		跨站脚本攻击，一种代码注入攻击，攻击者通过在网站上注入脚本，从而导入用户的cooike等

​		本质就是，网站没有对恶意代码进行过滤，导致与正常代码混合

​		通过xss攻击可以做到

​			1. 获取页面的数据，如DOM，cookie，localstorage

​			2. dos攻击，发送请求，占用服务器资源，从而使用户无法访问服务器

​			3. 破幻页面的结构

​			4. 流量劫持，将连接指向某钓鱼网站

​		种类分为：存储型、反射型、DOM型

​		存储型：提交恶意代码存储到数据库，然后数据库返回恶意代码与正常的html结合，执行恶意代码，就会窃取用户的数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站的接口执行操作，通常攻击带有用户保存数据的网站功能，比如私信，评论等去操作

​		反射型：通过特殊的URL，其中包含恶意代码，当用户打开时，服务端就会把恶意代码取出去执行，然后就可以窃取用户的数据并发送到攻击者的网站，或者冒充用户的行为，去执行目标网站的操作，常见的反射型，在url传递参数的时候，比如网站搜索、跳转，由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击

​		反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。

​		DOM型：通过特殊的URL，用户打开带有恶意代码的URL，浏览器去执行这个URL中的代码，窃取用户的数据，发送给攻击者的网站，或者冒充用户的，执行目标网站的操作

​		DOM型和其他两种的区别，DOM型完全是由浏览器端自己完成，是属于javascript的安全漏洞，而其他两个是服务端的漏洞，

​		如何防御？

​			1、第一种纯前端的方式，就是不用服务端拼接后返回也就是不使用服务端渲染，第二种就是对于拼接的html的代码进行充分的转义，

​			2、使用csp，也就是白名单，告诉浏览器那些外部资源可以加载和执行，需要用户配置规则，如何拦截由浏览器完成，通常有两种方式开启，一种是http头部字段的content-security-policy，还有一种使用meta标签 设置属性http-equiv=

​			3、对敏感信息进行保护，比如开启cookie的httponly，这样脚本就无法获取到cooike了，也可以使用验证码，避免脚本伪造成用户执行一些操作

​	2、csrf攻击

​			跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，如何该网站向被攻击者去发送网络请求，就是利用用户的登录状态去执行服务器的一些操作

​			本质就是cookie会在同源请求中携带发送服务器的特点，依次来冒充用户

​			攻击类型有三种

​				get请求，比如img标签里放一个请求，当用户打开这个网站就会自动提交

​				post攻击，构建一个隐藏表单，当用户打开这个网站就会自动提交

​				链接请求的csrf攻击，比如a标签中的herf构建一个请求，然后诱导用户点击

​	如何防御？

​			1、使用同源检测，就是判断origin和referer是否来自于允许访问的站点，从而对请求进行过滤，但是referer容易被伪造

​			2、csrfToken进行验证，返回一个随机数token，每次请求的时候带上这个token

​			3、对cookie进行双重验证，也就是注入一个cookie，请求的时候，把cookie添加到url参数中，服务器去比较，利用的是攻击者无法获取到cookie，但是有一个问题，就是如果存在xss漏洞，该方案就会失效，同时不能做到子域名的隔离		

​			4、设置cookie的属性samesite，即限制cookie不能被第三方使用，严格模式，宽松模式，普通模式（目标网站可以发送cookie）

​		

### 46、**回流和重绘是什么，有什么区别?**

dom结构发发生改变

重绘也就是样式发生改变

操作DOM时，尽量在低层级的DOM节点进行操作
●不要使用table布局， 一个小的改动可能会使整个table进行重新布局
●使用CSS的表达式
●不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
●使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
●避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中
●将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
●将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。



浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列

**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**
