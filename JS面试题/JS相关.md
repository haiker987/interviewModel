### 1、对原型链的理解

javascript 对象里有一个属性叫 prototype，也称作原型，它指向另一个对象或者 null---Object.`__proto__`.Prototype=null，
当我们查找某个属性和方法时，会按照原型链一步一步向上查找，直到找到该属性和方法，或到达原型链顶端即 Object.prototype 为止

目的节省内存----可以继承、共享属性和方法

### 2、map 和 Object 的区别 

1.键的类型 2. 键值对的顺序 3.大小的获取 4.原型链 5.迭代器：

### 3、this 指向

this是一个关键字，它指向的是它调用的对象

当函数被调用的时候会创建函数执行上下文，它包含了函数在哪调用的（调用栈）、函数的调用方式、以及传入的参数等信息，this就是这个记录的属性，在函数只执行的时候会被用到

函数调用方式

1. 普通函数调用：这是最基本的函数调用方式，通过函数名和参数列表来调用函数。例如，在 JavaScript 中可以使用 `functionName(argument1, argument2)` 的形式来调用函数。
2. 递归调用：函数可以直接或间接地调用自身，这种方式被称为递归调用。递归在算法和数据结构中经常被使用，例如在树的遍历和排序算法中。
3. 匿名函数调用：在一些编程语言中，可以直接定义并调用匿名函数，而不需要给函数命名。这种方式在函数式编程语言中很常见。
4. 回调函数调用：在异步编程中，可以将函数作为参数传递给其他函数，在特定的事件发生时进行回调。这种方式在事件驱动的编程模型中经常被使用。
5. 方法调用：在面向对象编程中，函数可以作为对象的方法进行调用，通过对象实例来调用函数。
6. 动态调用：一些编程语言支持动态调用函数，可以在运行时根据条件来确定调用哪个函数。

常见有四种指向：默认绑定，隐私绑定，显示绑定（call、apply、bind），new 绑定
<img src="image.png" alt="Alt text" style="zoom:67%;" />

  **特殊的this指向**
1、setTimeout 和 setInterval   --window
2.forEach、find、findIndex、map ---，第二个参数，为空就是window
3.IIFE立即执行函数--window
4、箭头函数 ---

### 4、闭包的作用、原理和使用场景

闭包让你可以在一个内层函数中访问到其外层函数的作用域，闭包其实就是一个可以访问其他函数内部变量的函数。即一个定义在函数内部的函数，或者说闭包是个内嵌函数。

作用：利用闭包实现缓存

闭包产生的本质就是：**当前环境中存在指向父级作用域的引用。**

#### 下面来看看闭包的表现形式及应用场景

1、在定时器、事件监听、Ajax 请求、Web Workers 或者任何异步中，只要使用了回调函数，实际上就是在使用闭包：

2、**作为函数参数传递的形式：**

3、IFE（立即执行函数），创建了闭包，保存了全局作用域（window）和当前函数的作用域，因此可以输出全局的变量：

4、**结果缓存（备忘模式）**

### 5、**正向代理和反向代理的区别**

正向代理和反向代理是两种不同类型的代理服务器，它们在网络通信中扮演不同的角色。

1. 正向代理（Forward Proxy）：
   - 正向代理作为客户端的代理，代表客户端向其他服务器发送请求。客户端需要通过正向代理来访问其他服务器，因为直接访问会受到限制或阻止。
   - 举个例子，当你在公司内部网络中访问互联网时，你可能需要通过公司的正向代理服务器来访问外部网站，因为公司的网络设置了防火墙或者其他安全限制。
2. 反向代理（Reverse Proxy）：
   - 反向代理作为服务器的代理，代表服务器接收客户端的请求并将请求转发到内部的服务器。客户端不知道自己实际正在与哪个服务器通信，因为所有的请求都是发送到反向代理服务器。
   - 举个例子，当你访问一个网站时，你实际上在与反向代理服务器通信，它会将你的请求转发到后端的多个服务器上，然后将结果返回给你。

总的来说，正向代理是代表客户端发出请求，而反向代理是代表服务器接收请求。它们的主要区别在于代理的角色不同，以及它们在网络通信中的位置和功能不同。

### 6、箭头函数和普通函数的区别

### 7、ES6新特性

### 8、promise.all和promise.allSettled的区别

### 9、subString、subStr区别

### 10、symbol作用和使用场景

### 11、JS脚本异步加载

### 12、typeof和intanceof区别

### 13、forEach、map是否可以break

### 14、如何判断数组类型

### 15、操作数组元素的方法有哪些

```
1。Object.prototype.toString.call(obj).slice(8,-1) ---'Array'
2.Array.isArray()
3.obj.__proto__===Array.prototype
4.obj instanceof Array
5.Array.prototype.isPrototypeof(obj)
```

### 16、sort排序算法的本质？

### 17、如何拷贝一个对象？如何实现深浅拷贝

#### 1、浅拷贝

```javascript
1.直接赋值
2。使用Object.assign()
3.扩展运算符
4.手写浅拷贝
```

#### 2、深拷贝

```javascript
1.JSON.stringify()
2.lodash.cloneDeep()
3.手写深拷贝
```

### 18、splice和slice会改变原数组吗？如何删除数组最后一个元素？

```javascript
1.splice(-1,1)
2.slice(0,-1)
3.pop()
4.delete a.length-1
```

### 19、0.1+0.2为什么不等于0.3？

```javascript
1.二进制转换的过程中精度丢失
2.计算的过程中精度丢失

解决：
	1.将数字转化成整数
    2.使用第三方库
    3.使用tofixed
```

### 20、 **== 和 === 的区别**

```javascript

```

### 21、**解释 requestAnimationFrame/requestIdleCallback，分别有什么用**

requestAnimationFrame 和 requestIdleCallback 都是浏览器提供的用于在下一次浏览器重绘之前执行指定函数的方法，它们的作用类似。它们的区别在于：

1. 回调函数的执行时机：requestAnimationFrame 的回调函数在下一次浏览器重绘之前执行，通常为每秒60次（60fps）；而requestIdleCallback 的回调函数在浏览器空闲时执行，即在浏览器没有其它任务时执行，通常为每秒几次（不确定，取决于浏览器）。
2. 回调函数的参数：requestAnimationFrame 的回调函数会被传入一个时间戳参数，表示当前帧开始渲染的时间；而requestIdleCallback 的回调函数会被传入一个 IdleDeadline 对象，包含了当前空闲时间的一些信息。 因此，当需要在下一次浏览器重绘之前执行某些操作时，应该使用requestAnimationFrame；当需要在浏览器空闲时执行一些较为耗时的操作时，应该使用requestIdleCallback。使用这两个方法可以避免造成页面卡顿或阻塞，提高用户体验。需要注意的是，由于requestIdleCallback的回调函数可能会在多次空闲时间内执行，因此应该根据实际情况合理地控制回调函数的执行次数和执行时间，以避免占用过多的浏览器资源

### 22、**解释 requestAnimationFrame/requestIdleCallback，分别有什么用**

RAF和RIC都是浏览器用于在下一次浏览器重绘之前执行指定函数的方法，他们的作用类似

RAF是用下一次浏览器重绘之前执行，通常时间为60s，而RIC是需要在浏览器空闲去执行的，如果没有空闲时间是不会执行的

### 23、谈下事件循环机制？

首先，浏览器的所有任务都是在一条线程上处理，即单线程

这样的坏处是，当执行一条任务时，这条任务执行的时间很长或者无响应，就会阻塞后面的任务，所以浏览器给出了一个方案，就是分为同步任务和异步任务，

异步任务是包括宏任务和微任务

其中常见的宏任务有全局的Script、settimeout、setInterval、IO操作、UI交互操作、以及nodejs中的setimmediate

常见的微任务有：Promise.then、async,await promise的语法糖、Process.nexTick、mutaionObserver

浏览器的EventLoop：

首先浏览器在执行代码的时候有两个概念，一个是执行栈，一个是任务队列

栈是先进后出，也就是函数的执行的时候，是后进去的先执行，pop（）

任务队列是先进先出，也就是当有宏任务或者微任务的时候，都会放进各自的任务队列里去等待执行，shift（）

总结：

在浏览器执行代码的过程中，首先执行全局的同步的代码，执行的过程中，如果发现有宏任务或者微任务，就会放进各自的任务队列去等待完成，随着同步的任务执行完成，先会去查看微任务队列是否存在任务，如果不存在就会开始将宏任务中的第一个任务取出，去执行；如果存在那就回优先执行微任务队列的任务；当执行宏任务的时候，如果宏任务中也包含微任务的话，那就会继续把微任务放进微任务队列，然后依次去执行微任务队列，直到所有的宏任务和微任务都执行完成，浏览器的一次事件循环就结束了

#### 说一下node环境中的事件循环

首先node中也含有像浏览器中的一些异步操作，例如：IO操作：readFIleAsyc、process.nextTick、setImmdeiate

还有就是node中其实是利用libuv去执行js脚本，以及node，他们是怎么操作的呢？

首先v8引擎会去处理js脚本，node处理解析后的代码，而libuv库就是去处理nodeAPi的执行，将他们分配给不同的线程去执行，形成一个eventloop，最后以异步的形式去返回结果给v8引擎

一共六个阶段

timer阶段：处理定时器等，回调是在poll阶段执行

io操作阶段：处理io事件，回调也是在poll阶段执行

idle，prepare阶段：处理系统事件，可以忽略

poll阶段:处理timer的回调和io的回调

check阶段：处理setlmmdeiate的回调

close阶段：处理close的回调

其中poll阶段比较复杂，分为几种情况：

如果没有设定timer时间（timer时间为下一次触发时间减去当前时间），

则poll队列是否为空，如果不为空的话，就会遍历去执行所有的回调，直到回调完成或者达到系统限制（这里的系统限制指的是系统的递归深度，默认为1000）；

如果为空的话，则会判断setlmmdeiate是否有回调需要执行，如果有则会进去check阶段去执行回调；如果没有回调要切执行，它就会等待回调被加入到队列中，这个等待时间是有限制的，不会无限的等待下去。

如果有设定timer时间且poll队列为空的话，则会判断是否有timer超时，如果有的就会回到timer阶段执行回调，如果队列不为空，则执行回调

### 24、**介绍一下防抖和节流**

防抖：防抖就是事件被触发n秒后再执行回调函数，可能在n秒内又触发了这个事件，则会重新计时，这样就确保了最后一次触发事件的n秒后去执行回调函数，从而减少回调函数的调用次数

节流：节流就是在一段时间内只会执行一次回调函数，如果在这段时间内又触发了这个事件，则忽略该事件，这样就确保了最后一次触发事件的n秒后去执行回调函数，从而减少回调函数的调用次数

时间戳版可能无法指定时间去执行回调函数

```javascript

```

### 24、**事件冒泡和捕获的区别？默认是冒泡还是捕获？**

事件流指的是，事件触发的顺序会按照先捕获和冒泡的规则，也就是捕获阶段，目标阶段，冒泡阶段

事件冒泡：事件接受后，开始逐级向上传播到Dom的顶层节点的过程

div > body > html >document >window

事件捕获：document对象在接受到点击事件后，会沿着dom树向下传播，直到传播到事件的目标位置

window > document > html > body > div

默认是冒泡

onclick 和attchevnet只能获取冒泡阶段

addEventListener 的第三个参数如果是true的话，则表示是捕获阶段，默认是false，也就是冒泡阶段

有些事件没有事件冒泡，如 blur 、focus、mouseenter、mouseleave

#### 如何阻止事件冒泡呢

1.可以使用e.stopProgation阻止事件冒泡 // 

2.使用addEventListener 的第三个参数设置为true，也就是捕获阶段

阻止默认行为

addEventListener 的话只有一种 e.preventDefault

如果是onclick 可以使用return false



冒泡的应用也就是事件委托也叫事件代理

### 25、**什么是事件代理？**

也就是通过事件捕获或者事件冒泡，把一系列内层元素的事件绑定到外层元素，作用是减少操作的Dom的次数，提高程序的性能并且在动态添加或删除列表项时也不需要重新绑定事件处理程序，这使得代码更加简洁、灵活且易于维护。

比如动态创建子元素，给ul绑定事件，那每一个子元素也会有事件

### 26、**mouseover 和 mouseenter 的区别？**





### 27、**浏览器缓存策略**

两种，强缓存和协商缓存

强缓存：

expires：http1.0

cache-control:http1.1



协商缓存：

last-modified：http1.0

Etag：http1.1



### 28、**浏览器内核是什么？包含什么？常见的有哪些？**

浏览器内核是由js引擎和渲染引擎组成的

 （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；
 （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；
 （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；
 （4） Safari 浏览器内核：Webkit 内核；
 （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；
 （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；
 （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
 （8） 百度浏览器、世界之窗内核：IE 内核；



### 29、**打开了两个标签页是进程还是线程？**

进程

打开浏览器的一个页面，需要四个进程： gpu进程、渲染进程、网络进程、浏览器进程（插件进程）



渲染进程中的线程

gui线程

js引擎线程

计时器线程

http线程

事件触发线程

### 30、**浏览器从输入网址到页面加载的整个过程** 

1、解析url：

2、缓存判断：

3、dns解析

4、获取mac地址

5、tcp三次握手

6、https握手

7、返回数据页面渲染

8、tcp的四次挥手

### 31、**前端模块化机制？**

五种：

commonjs、amd、cmd、umd、esmodule、IIFE自执行函数

### 32、**ES Module 和 commonjs 的区别？**

es6module是值的引用，commonjs是值的拷贝

es6是编译的时候输出接口，commonjs是运行才加载

es6是异步加载，commonjs是同步加载，因为commonjs是运行在node中，文件在本地，而es6是在浏览器运行，所以需要支持异步加载

es6支持tree-shaking，commonjs不支持

### 33、**cookie、localStorage、sessionStorage、IndexedDB 的区别？**

4k 5M 5M

### 34、**cookie 里面都包含什么属性？**

1. Domain：设置主机名，设置浏览器允许哪些主机可以访问cookie；作用，减少域的限制并可以在子域里访问

2. Path:指定访问cookie的必须存在请求url中的路径，除了使用域之外，还可以使用路径

3. Expires/max-size：设置cookie的过期时间，如果没有设置，那么就是和session一起失效

4. secure：https才可以访问

5. httponly：使cookie只能通过服务端访问，并且客户端无法通过js去获取 很重要，可以防止xss攻击

   

### 35、**Cookie能跨域吗？如何设置？**

同一域名下，cookie是可以的共享的，而不同域名下，默认情况下是不共享的

可以跨域，需要设置

1. 响应头设置Access-Control-Allow-Credentials: true，表示允许发送cookie，与前端的withCredentials配合使用
2. 响应头设置Access-Control-Allow-Origin：域名，请求域名，表示允许该域名下的请求访问资源

### 36、**对 CORS 的理解**



### 37、**如何检查内存泄露?**



### 38、**https 加密是怎样的?**



### 39、**HTML文档的生命周期有哪些？**



### 40、**如何解决跨域问题？**



### 41、**Content-Type 值有哪些？**



### 42、**常见状态码的含义？**



### 43、**get 和 post 的区别？**



### 44、**HTTP 2.0 有哪些改进？**



### 45、**XSS和CSRF是什么？如何防御？**



### 46、**回流和重绘是什么，有什么区别?**



### 47、**对盒子模型的理解**



### 48、**CSS选择器有哪些？**



### 49、**伪类和伪元素区别**



### 50、**如何计算 CSS 优先级？**



### 51、**预处理器（scss、less ）与 css 的区别**



### 52、**position 有哪些值，作用分别是什么?**



### 53、**flex布局有什么好处?**



### 54、**flex:1 是什么意思？**



### 55、**CSS 实现三角形**



### 56、**如何在浏览器可视区域画一个最大的正方形**



### 57、**CSS3 有哪些新特性？**



### 58、**如何设置一个 0.5px 的线？**
